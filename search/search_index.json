{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"404 Proxy","text":""},{"location":"#404-home","title":"404 - Home","text":""},{"location":"#reclaim-your-digital-anonymity","title":"Reclaim Your Digital Anonymity","text":"<p>Local by design. Illegibility on purpose.</p> <p>v1.1 available</p> <p>New builds are live. If you\u2019re upgrading, skim the release notes before swapping profiles.</p> <p></p> <p>Get Started GitHub</p>"},{"location":"#core-capabilities","title":"Core capabilities","text":"<pre><code>sequenceDiagram\n    participant F as Alice\n    participant 404\n    participant A as Ad-Tech Corporations\n    F-&gt;&gt;404: Hi, Google! I am using Firefox on Windows\n    404-&gt;&gt;A: Hi, Google! I am using Chrome on macOS\n    A-&gt;&gt;404: Hi, Alice! Here is your webpage for Chrome on macOS.\n    404-&gt;&gt;F: Here is your webpage.</code></pre>"},{"location":"#anti-fingerprinting","title":"Anti-fingerprinting","text":"<p>404 targets correlation: offers coherent profiles across TLS \u2192 headers \u2192 JS surfaces.</p>"},{"location":"#cross-platform","title":"Cross-platform","text":"<p>Written in Rust for Windows, macOS, Linux. Run locally, keep control locally.</p>"},{"location":"#open-source","title":"Open source","text":"<p>Full transparency.</p>"},{"location":"#the-leakage-problem","title":"The leakage problem","text":"<p>Your browser is telling ad-tech corporations too much.</p> <p>Websites and fingerprinting vendors collect semi-unique signals and combine them into a \u201cpersonality cloud\u201d:</p> <ul> <li>Canvas and text rendering quirks  </li> <li>WebGL parameters and GPU hints  </li> <li>Audio context characteristics  </li> <li>Fonts and device enumeration  </li> <li>Locale/timezone/screen geometry  </li> <li>TLS and header shapes</li> <li>Typing speed</li> </ul> <p>404 sits in the middle and rewrites your fingerprint before it leaves your machine.</p>"},{"location":"#what-404-changes","title":"What 404 changes","text":"<ul> <li> <p> TLS Fingerprint</p> <p>404 controls handshake behavior as a profile decision: extensions, ordering, ALPN, key shares, and cipher preferences are defined in the profile.</p> <p>Note</p> <p>TLS impersonation fidelity is adversarial and evolving. The goal is plausible identity.</p> </li> <li> <p> Network Telemetry</p> <p>Rewrites TCP/IP options such as MSS, Window Size/Scale, TTL, and more. These values can be passively collected and used to offer details on your network stack. Tools like nmap and p0f exploit these network telemetry signals to identify your hardware, OS, network environment, and more.</p> </li> <li> <p> HTTPS Headers</p> <p>Normalizes and rewrites headers and header ordering to match the chosen persona.</p> <ul> <li>Consistent <code>User-Agent</code> + client hints  </li> <li>Language/timezone coherence  </li> <li>Optional downgrades/strips to reduce leak paths (e.g., <code>Alt-Svc</code> preventing accidental HTTP/3/QUIC identity drift)</li> </ul> </li> <li> <p> JavaScript Fingerprint Surfaces</p> <p>Injects a profile-driven spoofing layer (canvas/WebGL/audio/fonts/media devices, etc.) while keeping the identity coherent.</p> <p>Tip</p> <p>Coherence beats randomness. Random noise is how you become a rare, clusterable outlier.</p> </li> </ul>"},{"location":"consent/","title":"404 Consent & Warning","text":""},{"location":"consent/#quick-consent-warning","title":"Quick consent &amp; warning","text":"<p>By running this software you understand that:</p> <ul> <li> <p>This proxy will generate a local CA and key-pair on its first run. As of now, there is no functionality or instructions for removing these from your trust store.</p> </li> <li> <p>This proxy terminates TLS, usernames and passwords that pass through this proxy may be temporarily stored/visible in local only logs. Do not share logs. </p> </li> <li> <p>This is beta software - no warranty, no guarantees, minimal support.</p> </li> </ul> <p>...and agree that:</p> <ul> <li> <p>You will not use your primary accounts.</p> </li> <li> <p>You will not share your CA certificate with anyone.</p> </li> <li> <p>If you find a security issue report it to 404co@proton.me</p> </li> </ul> <p>Join the Discord for support!</p> <p>Main Discussion: GitHub discussions</p> <p>Alternative community options coming soon!</p>"},{"location":"contact/","title":"Contact Us","text":""},{"location":"contact/#contact-us","title":"Contact Us","text":"<p>Have questions, feedback, or need support? We'd love to hear from you.</p>"},{"location":"contact/#email","title":"Email","text":"<p>Reach out to us at: 404co@proton.me</p> <p>We typically respond within 24-48 hours.</p>"},{"location":"contact/#other-ways-to-connect","title":"Other Ways to Connect","text":"<ul> <li>GitHub Issues: Report bugs or request features</li> <li>Discussions: Join the conversation on GitHub</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#faq","title":"FAQ","text":""},{"location":"faq/#does-404-make-me-anonymous-online","title":"Does 404 make me anonymous online?","text":"<p>No. Our goal is not to offer nation-state level evasion.</p> <p>If you require anonymity and/or plausible deniability from your online activity, there are tools that are better suited for your needs. </p> <p>404 aims to offer protection from commercial grade fingerprinting tools used by ad-tech companies like Google who collect and sell your data to third parties. Paired with a VPN, 404 offers fingerprint protection from most commercial grade fingerprinting tools (dataDome, FingerprintJS, etc.)</p>"},{"location":"faq/#how-does-404-work","title":"How does 404 work?","text":"<p>404 pretends to be you as well as the server.</p> <p>In essence, your machine thinks it is talking to a website (google.com) and the website thinks it is talking to you (Firefox on Windows), but in reality both your machine and the server are talking to your locally hosted instance of 404.</p> <p>YOU \u2192 404 \u2192 <code>google.com</code></p> <p><code>google.com</code> \u2192 404 \u2192 YOU</p> <p>This means that no website you visit sees your real fingerprint, only the one dictated by whatever 404 profile you're running.</p>"},{"location":"faq/#does-404-ever-see-my-data-andor-logs","title":"Does 404 ever see my data and/or logs?","text":"<p>No, BUT the local app has clear access to the contents of your web traffic. Those logs never leave your machine.</p> <p>404 hosts no infrastructure, nor do we plan to. In order to collect your data, we would need to host servers and allow you to connect to them. </p> <p>No information ever leaves your machine and all mutation happens locally. Always.</p>"},{"location":"faq/#does-404-change-my-ip-address","title":"Does 404 change my IP address?","text":"<p>No.</p> <p>In order to change your IP address, 404 would have to route your traffic. This goes against our core principles of local first mutation. You can, however (and should), follow the VPN integration steps to ensure that your persona location matches that of your VPN's advertised country. </p>"},{"location":"faq/#what-is-localhost","title":"What is <code>localhost</code>?","text":"<p>Localhost is the local interface that 404 listens on. Every machine comes with a pre-programmed private address, <code>127.0.0.1</code>, that allows local services to perform necessary tasks.</p> <p>When you send a packet to <code>localhost</code>/<code>127.0.0.1</code>/<code>lo</code>, you are sending the packet back to its host machine. Applications pair this with a <code>port</code> (4040 in our case) to allow a computer to operate on data locally. </p> <p>By default 404 listens on <code>localhost:4040</code> but this can be changed to any desired port. There is also functionality to change the listening interface (e.g. <code>0.0.0.0</code> for all interfaces), but this is not suggested as this opens your proxy up to all devices on your <code>LAN</code></p>"},{"location":"Overview/","title":"About Us","text":""},{"location":"Overview/#about-us","title":"About Us","text":""},{"location":"Overview/#who-we-are","title":"Who We Are","text":"<p>404 is a local TLS-terminating proxy built to address cross-session tracking through active fingerprint spoofing. It's currently maintained by a solo developer with a background in systems engineering, computational modeling, and education.</p> <p>The project was founded in 2024 after recognizing that existing privacy tools (e.g. VPNs, private browsing modes, ad blockers) no longer address passive fingerprinting techniques that operate across multiple layers of the network stack. 404 is an attempt to give individuals and organizations practical control over how their devices appear on the web.</p>"},{"location":"Overview/#our-ethos","title":"Our Ethos","text":"<ul> <li> <p> Privacy as Default Infrastructure</p> <p>Your device shouldn't broadcast dozens of unique identifiers every time you visit a website. Persistent tracking should not be the invisible default.</p> </li> <li> <p> Local-First, Always</p> <p>404 runs entirely on your machine. No cloud backends. No telemetry. Your data never touches our servers because we don't have servers.</p> </li> <li> <p> Transparency Through Open Source</p> <p>Every line of code is public.</p> </li> <li> <p> Accessible Privacy Tools</p> <p>Anti-fingerprinting is technically demanding. A major goal of 404 is making privacy accessible to those who need it most.</p> </li> </ul>"},{"location":"Overview/#why-we-exist","title":"Why We Exist","text":"<p>Cross-session tracking has become foundational infrastructure for the modern web. It operates without meaningful consent, is difficult to detect, and is increasingly centralized through a small number of ad-tech and fraud-prevention vendors. Nearly all internet users are now subject to continuous, non-consensual measurement; infrastructure that lends itself to population-scale profiling.</p> <p>The acute impact falls on communities operating under heightened scrutiny. Journalists, immigration attorneys, human rights organizations, and researchers rely on the open web to investigate sensitive topics, communicate with peers, or gather information on behalf of vulnerable populations. In these contexts, persistent client fingerprinting enables the correlation of browser activity across sessions, sites, and networks\u2014exposing intent, professional focus, and organizational relationships. This creates tangible risk: legal pressure, political targeting, data breaches, and chilling effects on inquiry and advocacy.</p> <p>Existing defensive tools no longer address this problem:</p> <ul> <li>VPNs hide your IP, but fingerprinting doesn't need it.</li> <li>Incognito mode clears cookies, but your device signature remains identical.</li> <li>Ad blockers stop requests, but servers still collect device telemetry.</li> <li>Privacy Browsers work but trade convenience and break many modern sites.</li> </ul> <p>404 addresses this gap by giving individuals and organizations practical control over how their devices appear on the internet. Rather than attempting to block trackers, 404 intercepts and modifies traffic to present believable but false device profiles, reducing linkability across sessions while remaining compatible with the modern web.</p>"},{"location":"Overview/#the-problem","title":"The Problem","text":""},{"location":"Overview/#passive-fingerprinting","title":"Passive Fingerprinting","text":"<p>Modern tracking techniques collect hundreds of semi-unique data points to build device profiles that persist across:</p> <ul> <li>Cookie deletion</li> <li>Private browsing sessions  </li> <li>VPN connections</li> <li>Different browsers on the same device</li> <li>Network changes</li> </ul> <p>Commercial fingerprinting services achieve 99.5%+ accuracy in identifying returning users. This type of metadata surveillance enables adversaries to map associations, track presence, monitor organizational behavior, and correlate activity without breaking encryption.</p>"},{"location":"Overview/#population-scale-monitoring","title":"Population-Scale Monitoring","text":"<p>Tracking operates on multiple layers that most privacy tools are not designed to control. If left unaddressed, passive fingerprinting will continue to normalize population-scale monitoring as an invisible default, further entrenching power imbalances between centralized tracking infrastructures and the communities they observe.</p>"},{"location":"Overview/#the-illusion-of-consent","title":"The Illusion of Consent","text":"<p>\"Cookie consent\" banners are theater. By the time you see them, your fingerprint has already been logged, correlated, and sold. GDPR and CCPA are steps forward, but enforcement is weak and technical evasion is complex.</p>"},{"location":"Overview/#development-status","title":"Development Status","text":"<p>404 is in active development. Current priorities:</p> <ul> <li>More profiles (Safari, mobile browsers, Linux configs)  </li> <li>Improved consistency (reducing edge-case leaks)</li> <li>Better UX (reducing manual configuration)</li> <li>External security audit (for components that introduce the most technical risk)</li> <li>Community contributions (documentation, testing, profile tuning)</li> </ul> <p>404 is not built for mass adoption, yet. It is infrastructure for individuals and organizations that need practical control over fingerprinting.</p>"},{"location":"Overview/#contributing","title":"Contributing","text":"<p>404 is open source. Contributions are welcome in the form of:</p> <ul> <li>Testing to identify fingerprint leaks and edge cases</li> <li>Development for code, profiles, and eBPF components</li> <li>Research documenting new tracking techniques and mitigations</li> <li>Documentation improving onboarding and technical clarity</li> </ul> <p>Contribute on GitHub Join the Discussion</p>"},{"location":"Overview/#contact","title":"Contact","text":"<ul> <li>GitHub Issues: Bug reports and feature requests  </li> <li>GitHub Discussions: General questions and implementation discussion</li> <li>Email: See contact page</li> </ul>"},{"location":"Overview/whatIs/","title":"What is 404?","text":""},{"location":"Overview/whatIs/#what-is-404","title":"What is 404?","text":"<p>By leveraging a Blazing fast Rust privacy proxy &amp; a Linux kernel module, 404 offers full control over your machine's fingerprint.</p> <p></p>"},{"location":"Overview/whatIs/#your-personality-cloud","title":"Your \u201cPersonality Cloud\u201d","text":"<pre><code>flowchart LR\n  %% Zig-zag layout: left -&gt; middle -&gt; right\n  A[\"BROWSER_SIGNAL&lt;br/&gt;&lt;b&gt;[LEAKING]&lt;/b&gt;&lt;br/&gt;User-Agent: Mozilla/5.0 on macOS&lt;br/&gt;CanvasID: 9b:17:2f:aa:\u2026&lt;br/&gt;Fonts: 178 enumerated&lt;br/&gt;TLS: ClientHello: unique-ish\"]\n\n  B[\"404_PROXY&lt;br/&gt;&lt;b&gt;[INTERCEPT]&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;\u2022 Rewrite TLS plan&lt;br/&gt;\u2022 Normalize headers + ordering&lt;br/&gt;\u2022 Inject JS spoofing stack (profile JSON)\"]\n\n  C[\"SPOOFED_SIGNAL&lt;br/&gt;&lt;b&gt;[PROTECTED]&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;User-Agent: Mozilla/5.0 on Windows&lt;br/&gt;CanvasID: 0xFD42\u2026 (scrambled deterministically)&lt;br/&gt;Fonts: constrained + salted&lt;br/&gt;TLS: profile-aligned handshake shape\"]\n\n  A --&gt;|HTTPS request| B --&gt;|rewritten request| C\n\n  classDef leak fill:#2b1b1b,stroke:#ff6b6b,stroke-width:1px,color:#ffdede;\n  classDef mid  fill:#1b2433,stroke:#4b8bff,stroke-width:1px,color:#dbe9ff;\n  classDef safe fill:#1b2b1f,stroke:#4ade80,stroke-width:1px,color:#dcffe7;\n\n  class A leak;\n  class B mid;\n  class C safe;\n</code></pre> <p>404 houses two main modules: - STATIC Proxy - Synthetic Traffic and TLS Identity Camouflage - Linux eBPF module</p>"},{"location":"Overview/whatIs/#static-proxy","title":"STATIC Proxy","text":""},{"location":"Overview/whatIs/#synthetic-traffic-and-tls-identity-camouflage","title":"Synthetic Traffic and TLS Identity Camouflage","text":"<p>The heart of 404, built in Rust. </p> <p>Native values from FingerprintJS .</p> <p>Spoofed values from FingerprintJS .</p> <p>The STATIC proxy is wired specifically to give the user granular control over their online fingerprint. Not just their browser fingerprint, but any device or app they choose to route through the proxy.</p> <p>As it stands in v1.0, STATIC runs on <code>localhost:4040</code> by default, never exposing itself to the internet or any device other than the one that it is running on. The logic behind STATIC is pretty simple and mimics a lot of the high-level logic that <code>mitmproxy</code> employs. </p> <p>Requests are broken into <code>flows</code>. Each <code>flow</code> passes through multiple <code>stages</code>. A <code>stage</code> is where the request/response mutation happens.</p> <p>Request stages:</p> <ol> <li> <p>HeaderProfileStage - Rewrites headers based on your selected profile (User-Agent, Accept, sec-ch-ua, Accept-Language). Maintains strict ordering to match real browser behavior: remove -&gt; replace -&gt; replaceArbitrary -&gt; replaceDynamic -&gt; set -&gt; append.</p> </li> <li> <p>AltSvcStage - Downgrades or strips HTTP/3 advertisements to prevent protocol leakage.</p> </li> <li> <p>CspStage - Generates CSP nonces and rewrites Content-Security-Policy headers so injected scripts execute without breaking origin policies.</p> </li> <li> <p>JsInjectionStage - Embeds the fingerprint spoofing stack (bootstrap, globals shim, config layer, spoof scripts) at the beginning of <code>&lt;head&gt;</code>. Records SHA-256 hashes for CSP validation.</p> </li> <li> <p>BehavioralNoiseStage - Tags the flow with timing patterns for coordination between Rust and injected JavaScript.</p> </li> </ol> <p>Response stages:</p> <ol> <li> <p>CspStage - Finalizes CSP headers with script hashes and nonces, handles strict-dynamic policies, preserves origin inline scripts.</p> </li> <li> <p>JsInjectionStage - Performs the actual HTML mutation, decompresses responses if needed (gzip/deflate/brotli), injects scripts at the earliest safe insertion point.</p> </li> <li> <p>AltSvcStage - Strips or normalizes Alt-Svc headers in responses to prevent the browser from upgrading to HTTP/3.</p> </li> </ol> <p>Each stage runs asynchronously and can inspect or mutate the request/response. The pipeline is deterministic. Same profile, same mutations, same fingerprint.</p> <p>Don't believe me? Check my work... </p> <ul> <li>FingerprintJS</li> <li>Browser Leaks</li> <li>EFF - Cover Your Tracks</li> <li>What is my Browser</li> <li>HTTP bin</li> </ul>"},{"location":"Overview/whatIs/#linux-ebpf-module","title":"Linux eBPF module","text":"<p>The eBPF module is, again, quite simple. It leverages powerful, fast, well documented, low-level Linux kernel hooks. By attaching carefully crafted eBPF programs to Linux's Traffic Control (tc) egress hooks, we can mutate files extensively.</p> <p>Currently, the following is implemented: </p><pre><code>**IPv4:**\n- TTL (Time To Live) -&gt; forced to 255\n- TOS (Type of Service) -&gt; set to 0x10\n- IP ID (Identification) -&gt; randomized per packet\n- TCP window size -&gt; 65535\n- TCP initial sequence number -&gt; randomized (again)\n- TCP window scale -&gt; 5\n- TCP MSS (Maximum Segment Size) -&gt; 1460\n- TCP timestamps -&gt; randomized\n\n**IPv6:**\n- Hop limit -&gt; forced to 255\n- Flow label -&gt; randomized\n</code></pre>"},{"location":"Overview/why404/","title":"Why do I Need 404?","text":""},{"location":"Overview/why404/#why-do-i-need-404","title":"Why do I Need 404?","text":""},{"location":"Overview/why404/#404s-role","title":"404's Role","text":"<p>404 utilizes enterprise-tested solutions to change the fingerprint of any machine. </p> <p>Whether you're using a Macbook, PC, containerized application, an ad-blocker should not matter to the websites you visit. With 404, that information never leaves your machine, and the servers collecting your data are fed a false, believable fingerprint carefully crafted in-house.</p>"},{"location":"Overview/why404/#anatomy-of-a-fingerprint","title":"Anatomy of a fingerprint","text":"<p>Every machine is unique. Companies combine dozens of semi-unique values to create a single device fingerprint. This allows ad-tech companies to follow you across websites, time, incognito browsers, and even VPN sessions.</p> <p></p>"},{"location":"Overview/why404/#browser-fingerprinting","title":"Browser Fingerprinting","text":"<p>Your online fingerprint is becoming increasingly unique. Modern tracking doesn't just rely on cookies; it builds \"personality clouds\" from hundreds of data points: TLS handshake patterns (JA3/JA4), HTTP header combinations, canvas rendering quirks, microphone/speaker/headset model and brand, font enumeration, WebGL parameters, audio context characteristics, and behavioral timing patterns... to name a few.</p> <p>The collection of these semi-unique values (.nav properties, timezone, screen resolution, browser type, etc.) allows servers to pretty confidently identify users as not semi-unique, but entirely. </p> <p>Commercial fingerprinting services like FingerprintJS, Fingerprint.com, and DataDome can identify users across...</p> <ul> <li> <p>Different browsers on the same device</p> </li> <li> <p>Private/incognito modes (linked to 'public' browsing profile)</p> </li> <li> <p>VPN connections (or proxies, even residential ones)</p> </li> <li> <p>Cookie &amp; cache clearing </p> </li> <li> <p>Different networks</p> </li> </ul> <p>This isn't paranoia. This is surveillance capitalism.</p>"},{"location":"Overview/why404/#who-is-this-for","title":"Who is this for?","text":"<p>Anyone who's tired of being tracked across the web despite \"privacy tools\" that don't actually work against modern fingerprinting.</p> <p>404 has the capability to defeat modern fingerprinting techniques. </p> <p>The included profiles (<code>firefox-windows</code>, <code>chrome-windows</code>, <code>edge-windows</code>) produce consistent spoofed fingerprints but are still under active development. Setup is straightforward if you're comfortable with:</p> <p>If you\u2019re comfortable with manual maintenance and iteration, you\u2019ll get real privacy gains.</p>"},{"location":"Overview/why404/#the-bigger-picture","title":"The Bigger Picture","text":"<p>This isn't just a tool. It's proof that illegibility is technically feasible.</p> <p>As governments worldwide push for mandatory surveillance (Chat Control in the EU, client-side scanning proposals, \"lawful access\" backdoors), and as AI makes behavioral profiling trivial at scale, the ability to be untrackable becomes existential.</p> <p>404 demonstrates that privacy through illegibility isn't theoretical. It's implementable, it works, and it's available to anyone.</p>"},{"location":"Overview/why404/#why-shouldnt-i-install-and-run-this-on-my-machine","title":"Why shouldn't I install and run this on my machine?","text":"<p>This repository, in its current state, is built for researchers, developers, and privacy advocates who understand the trade-offs and are comfortable with...</p> <p>Manual configuration - Profiles require review and occasional tweaking based on your use-case and threat model. If you're confused about configuration, feel free to reach out in an email, open a GitHub issue, or submit a ticket in the Discord.</p> <p>!Occasional! breakage - Breakage is honestly limited to having to manually solve a captcha every now and again. Still, some websites will break, some login flows will fail, some features won't work. This is the nature of deep protocol mutation. If there's something critical, open a GitHub issue and I will try to find a workaround.</p> <p>Active maintenance - Browser updates change fingerprinting surfaces. Profiles need updating. You can't just \"set it and forget it.\" I will update as frequently as I can.</p> <p>Technical comlexity - It's a lot. I know, but honestly it kind of just works right now. It may get you rate-limited or flagged as a bot (I haven't been yet, and I run this jawn every day), but you should be able to pass Captchas and prove you're a human -- no, the pole is not a part of the 'street light.'</p> <p>I do not know the long term effects on account usage. I have been logging-in via this proxy using my personal Google, Microsoft, and Apple accounts for the last 9-ish months, and I have experienced no retaliation (bans and whatnot). That is not to say you will have the same experience. I strongly recommend that you use alternate/disposable accounts if you're going to be testing OAuth or other login flows.</p> <p>I am not a cybersecurity engineer. I hammered this together and may have missed something important. Feel free to reach out with security vulnerabilities @ 404co@proton.me</p>"},{"location":"dev/depsDev/","title":"Working with the 404 Repository","text":""},{"location":"dev/depsDev/#getting-started-with-the-repository","title":"Getting Started with the Repository","text":"<p>Step 1 - Download 404</p>"},{"location":"dev/depsDev/#requirements","title":"Requirements","text":"<p>Utilizing the eBPF module requires a Linux kernel (4.15+).</p> Component Version Install Link Rust 1.76+ INSTALL CMake Latest INSTALL NASM Latest INSTALL <p>You may install these manually, but it is often easier to install them via <code>brew</code> or <code>winget</code>. So open the Terminal and lets get started!</p>"},{"location":"dev/depsDev/#install-dependencies-configure-path","title":"Install dependencies &amp; configure PATH","text":"<p>All commands can be copy pasted into your terminal for easy usage!</p> WindowsmacOSLinux <p>Install via winget</p> <ol> <li> <p>Click here (32-bit) to download rust-up. Open the downloaded <code>.exe</code> file and follow setup instructions.</p> <ul> <li>Use the \u201cWorkload\u201d tab to select the \u201cDesktop Development with C++\u201d option.</li> <li>Help</li> </ul> </li> <li> <p>Open the Command Prompt</p> <ul> <li> <p>Press...  + r</p> </li> <li> <p>Type \"cmd\" into the run dialogue box.</p> </li> </ul> </li> <li> <p>Download the dependencies</p> </li> </ol> <pre><code>winget install --id Kitware.CMake -e &amp;&amp; winget install --id NASM.NASM -e\n</code></pre> <p>Restart your shell after installation. Tools should be on your PATH automatically. </p> <p>Install via homebrew (recommended) </p> <ol> <li> <p>Open the Terminal</p> <ul> <li>Press  + space</li> <li>Search \"Terminal\" and press Enter</li> </ul> </li> <li> <p>Ensure you have homebrew installed</p> <p>a. </p><pre><code>xcode-select --install \n</code></pre> <p>b. </p><pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> </li> <li> <p>Download dependencies w/ homebrew:</p> </li> </ol> <pre><code>brew install rust nasm cmake\n</code></pre> <p>Restart your shell after installation. Tools should be on your PATH automatically.</p> <p>Install via package manager</p> <pre><code># Debian/Ubuntu\n$ sudo apt update\n$ sudo apt install -y curl build-essential nasm cmake\n\n# Arch\n$ sudo pacman -S rust nasm cmake\n\n# Fedora/RHEL\n$ sudo dnf install -y rust cargo nasm cmake\n\n# Install Rust via rustup (if not installed via package manager)\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n$ source $HOME/.cargo/env\n</code></pre> <p>Step 3 - Start Proxy</p>"},{"location":"dev/downloadDev/","title":"Getting Started - Download 404","text":""},{"location":"dev/downloadDev/#getting-started-download-404","title":"Getting Started - Download 404","text":""},{"location":"dev/downloadDev/#download-easy","title":"Download (easy)","text":"<p>The simplest option is to download a zipped version of the repository. This does not guarantee an up-to-date version of the application.</p> <ol> <li> <p>Download .zip</p> <p>.zip file last updated: 2/11/2026</p> <p>Please be sure to move this .zip file to the location you would like it (e.g. <code>~/git/</code>) before unzipping the file. Though moving the repo is a simple enough process at any time, doing so now will save you from losing it in your <code>Downloads/</code> folder as well as allow you to use the commands provided more seamlessly.</p> </li> <li> <p>Create a new directory @ <code>~/git/</code> to house <code>404</code></p> </li> </ol> <p>You can do this using the following commands...</p> <p>All commands can be copy pasted into your terminal for easy usage!</p> Windows:Linux/macOS:OR... <p>Open the Command Prompt</p> <ul> <li> <p>Press...  + r</p> </li> <li> <p>Type \"cmd\" into the run dialogue box.</p> </li> </ul> <pre><code>if not exist \"%USERPROFILE%\\git\" mkdir \"%USERPROFILE%\\git\"\nmove \"%USERPROFILE%\\Downloads\\404.zip\" \"%USERPROFILE%\\git\\404.zip\"\ntar -xf \"%USERPROFILE%\\git\\404.zip\" -C \"%USERPROFILE%\\git\"\ndel \"%USERPROFILE%\\git\\404.zip\"\n</code></pre> <p>Open the Terminal</p> <ul> <li>Press  + space</li> <li>Search \"Terminal\" and press Enter</li> </ul> <pre><code>mkdir -p \"$HOME/git\"\nmv \"$HOME/Downloads/404.zip\" \"$HOME/git/404.zip\"\nunzip \"$HOME/git/404.zip\" -d \"$HOME/git\"\nrm \"$HOME/git/404.zip\"\n</code></pre> <p>By using the file explorer.</p> <p>Place the .zip file in <code>~/git/</code> and right-click on it to extract a new directory: <code>~/git/404</code>.</p>"},{"location":"dev/downloadDev/#clone-secure","title":"Clone (secure)","text":"<p>The best option is to use your command line to download the latest version of the repository from <code>Github</code> or <code>Codeberg</code>.</p> <p>1. Create a folder for 404 or navigate to your <code>git</code> directory.</p> Windows:Linux/macOS: <pre><code>mkdir -p %USERPROFILE%\\git\\\ncd %USERPROFILE%\\git\\\n</code></pre> <pre><code>mkdir -p ~/git/\ncd ~/git/\n</code></pre> <p>2. Clone to your local projects/ or git/ directory</p> <p>All operating systems:</p> <pre><code>git clone https://github.com/un-nf/404.git\ncd 404\n</code></pre> Windows clone <p>Use Command Prompt to clone the repository from GitHub.</p> <ol> <li> <p>Open Command Prompt</p> <ul> <li>Press...  + r</li> <li>Type \"cmd\" into the run dialogue box and press Enter</li> </ul> </li> <li> <p>Create (if needed) and enter your <code>git</code> directory</p> <pre><code>if not exist \"%USERPROFILE%\\git\" mkdir \"%USERPROFILE%\\git\"\ncd /d \"%USERPROFILE%\\git\"\n</code></pre> </li> <li> <p>Clone and enter the project folder</p> <pre><code>git clone https://github.com/un-nf/404.git\ncd 404\n</code></pre> </li> </ol> <p>If <code>git</code> is not installed, install Git for Windows from https://git-scm.com/downloads/win and rerun the commands.</p> macOS clone <p>Use Terminal to clone the repository from GitHub.</p> <ol> <li> <p>Open Terminal</p> <ul> <li>Press  + space</li> <li>Search \"Terminal\" and press Enter</li> </ul> </li> <li> <p>Verify that Git is installed</p> <pre><code>git --version\n</code></pre> </li> </ol> <p>If you see \"command not found\", install Apple Command Line Tools:</p> <pre><code>```zsh\nxcode-select --install\n\n```\n</code></pre> <ol> <li> <p>Create (if needed) and enter your <code>git</code> directory</p> <pre><code>mkdir -p \"$HOME/git\"\ncd \"$HOME/git\"\n</code></pre> </li> <li> <p>Clone and enter the project folder</p> <pre><code>git clone https://github.com/un-nf/404.git\ncd 404\n</code></pre> </li> </ol> <p>Step 2 - Download Dependencies</p>"},{"location":"dev/ebpf/","title":"Working with the 404 Repository","text":""},{"location":"dev/ebpf/#ebpf-kernel-module","title":"eBPF Kernel Module","text":"<p>Step 3 - Start Proxy</p>"},{"location":"dev/ebpf/#overview","title":"Overview","text":"<p>This eBPF program hooks into the Linux kernel's network stack at the TC egress point and modifies outgoing packets before they leave your machine. It rewrites packet-level fingerprints that are visible to network observers and can be used to identify your OS and network stack implementation.</p> <p></p> <p>The eBPF module modifies packet-level fingerprints (TTL, TCP window size, sequence numbers, etc.). This requires a Linux kernel.</p> <p>Kernel requirements</p> <ul> <li>CONFIG_BPF=y, CONFIG_BPF_SYSCALL=y, CONFIG_NET_CLS_BPF=y, CONFIG_NET_ACT_BPF=y</li> <li>Install: <code>clang</code>, <code>llvm</code>, <code>libbpf-dev</code>, <code>linux-headers-$(uname -r)</code>, <code>iproute2</code></li> </ul>"},{"location":"dev/ebpf/#configuration","title":"Configuration","text":"<p>Currently, IP/TCP packet header values are assigned via global variables at the top of <code>src/ebpf/ttl_editor.c</code>. They do not align with values passed from <code>profiles.json</code>, this is a major pitfall of the current version and will be integrated with dynamic <code>bpfmaps</code> in a future release.</p> <p>Modify hardcoded globals to desired values before compiling.</p> Native OS Options: OS TTL Window Size Window Scale ISN MSS* Timestamps TCP Option Order Windows 128 64 kb (64240 bytes) 8 Randomized Varies based on connection Not used MSS,NOP,WS,NOP,NOP,SACK MacOS 64 64 kb (65535 bytes) 6 Randomized Varies based on connection Internal counter MSS,NOP,WS,NOP,NOP,TS,SACK,EOL Linux 64 64 kb (65535 bytes - 5840 bytes for 2.4/2.6 kernels) 7 Randomized Varies based on connection Internal counter - sometimes randomized MSS,SACK,TS,NOP,WS Default Implementation Options <p>IPv4:</p> <ul> <li>TTL (Time To Live) \u2192 forced to 255</li> <li>TOS (Type of Service) \u2192 set to 0x10</li> <li>IP ID (Identification) \u2192 randomized per packet</li> <li>TCP window size \u2192 65535</li> <li>TCP initial sequence number \u2192 randomized (again)</li> <li>TCP window scale \u2192 5</li> <li>TCP MSS (Maximum Segment Size) \u2192 1460</li> <li>TCP timestamps \u2192 randomized</li> </ul> <p>IPv6:</p> <ul> <li>Hop limit \u2192 forced to 255</li> <li>Flow label \u2192 randomized</li> <li>TCP parameters (same as IPv4)</li> </ul> <p>1. Open <code>ttl_editor.c</code> and modify the <code>#define</code> values at the top: (optional)</p> <pre><code>#define FORCE_TTL 255\n#define SPOOF_TCP_WINDOW_SIZE 65535\n#define SPOOF_TCP_MSS 1460\n#define SPOOF_TCP_WINDOW_SCALE 5\n// etc.\n</code></pre>"},{"location":"dev/ebpf/#build-ebpf-program","title":"Build eBPF program","text":"<p>All commands can be copy pasted into your terminal for easy usage!</p> <p>1. </p><pre><code>cd src/ebpf\nmake deps-install  # shows dependency installation command\nmake               # compiles ttl_editor.o\n\n# Manual compilation\nclang -O2 -g -target bpf -D__TARGET_ARCH_x86 -I/usr/include/ -I/usr/include/linux -c TTLEDIT-STABLE.c -o &lt;output&gt;.o\n</code></pre>"},{"location":"dev/ebpf/#attach-to-network-interface","title":"Attach to network interface:","text":"<p>2. </p><pre><code>sudo tc qdisc add dev &lt;interface&gt; clsact\nsudo tc filter add dev &lt;interface&gt; egress bpf da obj ttl_editor.o sec classifier\n</code></pre>"},{"location":"dev/ebpf/#remove-from-interface","title":"Remove from interface","text":"<p>3. </p><pre><code>sudo tc filter del dev &lt;interface&gt; egress\nsudo tc qdisc del dev &lt;interface&gt; clsact\n</code></pre>"},{"location":"dev/ebpf/#configure-a-linux-vm-for-forwarding","title":"Configure a Linux VM for forwarding","text":"<p>Kernel requirements:</p> <ul> <li>CONFIG_BPF=y, CONFIG_BPF_SYSCALL=y, CONFIG_NET_CLS_BPF=y, CONFIG_NET_ACT_BPF=y</li> <li> <p>Install: <code>clang</code>, <code>llvm</code>, <code>libbpf-dev</code>, <code>linux-headers-$(uname -r)</code>, <code>iproute2</code></p> </li> <li> <p>Linux kernel 4.15+ (5.4+ recommended)</p> </li> </ul> <p>1. Ensure your VM has two network adapters:</p> <ol> <li><code>Bridged</code> - connects <code>VM/Guest</code> to internet</li> <li><code>Host-Only</code> - creates private network between <code>Host</code> and <code>VM/Guest</code></li> </ol> <p>2. Attach to network interface:</p> <p></p><pre><code>sudo tc qdisc add dev &lt;interface&gt; clsact\nsudo tc filter add dev &lt;interface&gt; egress bpf da obj ttl_editor.o sec classifier\n</code></pre> 3. Route host traffic through VM: <p>On <code>Linux VM</code> (Guest):</p> <pre><code># Enable IP forwarding\nsudo sysctl -w net.ipv4.ip_forward=1\necho \"net.ipv4.ip_forward=1\" | sudo tee -a /etc/sysctl.conf\nsudo sysctl -w net.ipv6.conf.all.forwarding=1\necho \"net.ipv6.conf.all.forwarding=1\" | sudo tee -a /etc/sysctl.conf\n\n# Allow forwarding on Host-Only interface\nsudo iptables -A FORWARD -i &lt;host-only-interface&gt; -j ACCEPT\nsudo iptables -A FORWARD -o &lt;host-only-interface&gt; -j ACCEPT\nsudo ip6tables -A FORWARD -i &lt;host-only-interface&gt; -j ACCEPT\nsudo ip6tables -A FORWARD -o &lt;host-only-interface&gt; -j ACCEPT\n\n# Enable NAT/masquerading on Bridged interface\nsudo iptables -t nat -A POSTROUTING -o &lt;bridged-interface&gt; -j MASQUERADE\nsudo ip6tables -t nat -A POSTROUTING -o &lt;bridged-interface&gt; -j MASQUERADE\n</code></pre> <p>On Host machine:</p> <ul> <li>Set default gateway to <code>VM/Guest</code> Host-Only adapter IP address</li> <li>(Windows: Network adapter settings \u2192 Properties \u2192 TCP/IPv4 \u2192 Gateway)</li> <li>(Linux/Mac: <code>sudo route add default gw &lt;vm-host-only-ip&gt;</code>)</li> </ul> <p>Some additional tinkering may be required. Feel free to leave a comment or open an issue with suggestions on improving the setup process.</p>"},{"location":"dev/ebpf/#verify-test","title":"Verify &amp; Test","text":"<p>1. Verify it's running:</p> <pre><code>sudo tc filter show dev &lt;interface&gt; egress\n</code></pre> <p>2. Verify w/ tcpdump output, some examples below:</p> <pre><code>tcpdump -i &lt;interface&gt; -vvv -Q out\n\n# View specific TCP/IP fields:\ntcpdump -i &lt;interface&gt; -vvv -c 20 -Q out 'tcp[tcpflags] &amp; tcp-syn != 0'  # SYN packets only (-c for 20 packets)\ntcpdump -i &lt;interface&gt; -vvv -nn -Q out | grep -E 'ttl|win|mss|wscale'  # Filter for specific fields\n\n# More detailed packet inspection:\ntcpdump -i &lt;interface&gt; -vvv -XX -Q out  # Show full hex dump\ntcpdump -i &lt;interface&gt; -vvv -Q out port 443  # HTTPS traffic only\n</code></pre>"},{"location":"dev/ebpf/#why-ebpf","title":"Why eBPF?","text":"<p>Tools like p0f and nmap can passively fingerprint an OS by analyzing packet-level characteristics. This eBPF program attempts to normalize these values to make passive fingerprinting harder.</p> <p>eBPF programs run in the kernel with strict safety guarantees enforced by the verifier. This program:</p> <ol> <li>Attaches to a network interface's TC egress hook</li> <li>Inspects every outgoing packet</li> <li>Modifies packet headers in-place (TTL, TCP options, etc.)</li> <li>Recalculates checksums where necessary</li> <li>Passes the modified packet onwards</li> <li>The verifier ensures the program can't crash the kernel, access arbitrary memory, or run forever. All bounds checks are verified at load time.</li> </ol> <p>Operating systems have distinct network stack implementations. Windows, Linux, macOS, Android, and iOS set different default values for TCP/IP packet headers (TTL, MSS, WinSize/Scale). These fingerprinting vectors are trivial to collect and can identify your OS even if you spoof your HTTP headers and browser fingerprint perfectly. Tools like nmap and p0f allow third party network observers to exploit this fingerprinting vector.</p> <p>Mismatches between network, JS, and HTTPS values can also be used by servers to identify bot-likely traffic and block connections.</p>"},{"location":"dev/startDev/","title":"Working with the 404 Repository","text":""},{"location":"dev/startDev/#getting-started","title":"Getting Started","text":"<p>Step 2 - Download Dependencies</p> <p>All steps assume that there is a folder named <code>404/</code> located at <code>~/git/</code></p>"},{"location":"dev/startDev/#run-the-proxy","title":"Run the proxy","text":"<p>All commands can be copy pasted into your terminal for easy usage!</p> Windows:Linux/macOS: <pre><code>cd %USERPROFILE%\\git\\404\\src\\STATIC_proxy # CHANGE to wherever you unzipped the 404 folder.\ncargo run  # This will take a while on the first run (~5-minutes)\n</code></pre> <pre><code>cd ~/git/404/src/STATIC_proxy # CHANGE to wherever you unzipped the 404 folder.\ncargo run  # This will take a while on the first run (~5-minutes)\n</code></pre>"},{"location":"dev/startDev/#trust-proxy-generated-ca","title":"Trust proxy-generated CA","text":"FirefoxWindowsmacOSLinux <p>Firefox uses its own trust store, you must trust the CA in the application:</p> <p>Firefox -&gt; Settings -&gt; Privacy &amp; Security -&gt; Certificates -&gt; View Certificates -&gt; Authorities tab -&gt; Import -&gt; select static-ca.crt -&gt; Check \"Trust this CA to identify websites\" -&gt; OK</p> <p>Trust the CA using <code>certutil</code></p> <pre><code>certutil.exe -addstore root C:\\\\path\\\\to\\\\myCA.pem\n</code></pre> <p>or manually... 1. Navigate to the <code>404/</code> directory and locate the <code>../static_proxy/certs/</code> directory. 2. Double-click the file labeled <code>static-ca.crt</code> (may appear without .crt extension) 3. Click <code>Install Certificate...</code> 4. Select <code>Current User</code> and click <code>Next</code> 5. Choose <code>Place all certificates in the following store</code> and click <code>Browse...</code> 6. Select <code>Trusted Root Certification Authorities</code> and click <code>OK</code> 7. Click <code>Next</code> then <code>Finish</code></p> <pre><code>sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain static_proxy/certs/static-ca.crt\n</code></pre> <p>Or use the GUI:</p> <ol> <li>Open Keychain Access</li> <li>File -&gt; Import Items -&gt; select static-ca.crt</li> <li>Find the certificate, double-click it</li> <li>Expand \"Trust\" and set \"When using this certificate\" to \"Always Trust\"</li> </ol> <pre><code># Copy CA to system trust store\nsudo cp static_proxy/certs/static-ca.crt /usr/local/share/ca-certificates/static-ca.crt\nsudo update-ca-certificates\n</code></pre>"},{"location":"dev/startDev/#configure-your-browser","title":"Configure your Browser","text":"<p>Set your browser (or system) to use <code>localhost:8080</code> (or <code>127.0.0.1:8080</code>) as an HTTP/HTTPS proxy.</p> <ul> <li>Chrome/Edge: Settings -&gt; System -&gt; Open your computer's proxy settings</li> <li>Firefox: Settings -&gt; Network Settings -&gt; Manual proxy configuration -&gt; HTTP Proxy: <code>127.0.0.1</code>, Port: <code>8080</code>, check \"Also use this proxy for HTTPS\"</li> </ul> <p>Important: This tool is a TLS-terminating proxy (man-in-the-middle) and has access to your plaintext HTTPS data (usernames, passwords, certain message protocols, etc.). Do NOT share your CA cert with anyone for anything, ever.</p> <p>UX on Firefox is slightly more stable for reasons that are not clear to me. Would love some insight. Login flows have been tested and are working in both browsers.</p>"},{"location":"dev/startDev/#optional-configure-a-linux-vm-if-not-using-linux","title":"Optional - Configure a Linux VM (if not using Linux)","text":"<p>VM Setup:</p> <p>VM images coming soon. I am using an Alpine distribution on WSL2 (Windows). Works well, but a little heavy. Definitely going to be looking into distributing the VMs as dedicated server images, not gerry-rigged forwarding machines with desktop environments.</p> <p>You 100% could configure a VM and route traffic from your host machine to a VM guest, instructions for VM configuration here.</p> <p>For now, just running STATIC should be enough, though network level obfuscation is not possible without a Linux kernel (yet).</p> <p>Step 4 (optional) - Setup eBPF</p>"},{"location":"getStart/appStart/","title":"404 Start","text":""},{"location":"getStart/appStart/#how-to-use-the-404-desktop-app","title":"How to use the 404 Desktop App","text":""},{"location":"getStart/appStart/#note","title":"Note","text":"<p>The 404 application is currently in development.</p> <p>Download 404 Watch Demo </p>"},{"location":"resources/ebpf/","title":"eBPF Guide","text":""},{"location":"resources/ebpf/#ebpf","title":"eBPF","text":"<p>eBPF Status</p> <p>The eBPF module, while functional, is currently undergoing major development. Documentation will follow the next major release.</p>"},{"location":"resources/repoDev/","title":"Working with the 404 Repository","text":"<p>Github</p> <p>Codeberg</p>"},{"location":"resources/static/","title":"STATIC Proxy Guide","text":""},{"location":"resources/static/#static-proxy","title":"STATIC Proxy","text":"<p>A ground-up Rust implementation of a fingerprint-resistant MITM proxy</p> <p>Deep Dive Ahead</p> <p>This page is designed for developers, researchers, and anyone who wants to understand how STATIC works under the hood. If you're just looking to get started, check out the Getting Started guide instead.</p>"},{"location":"resources/static/#what-does-static-do","title":"What does STATIC do?","text":"<p>Modern fingerprinting is a multi-layer problem. Spoofing just your User-Agent or randomizing canvas values creates incoherent, identifiable noise. STATIC exists because defeating commercial fingerprinting requires full-stack control.</p> <p>TLS Layer</p> <ul> <li>Rewrites the <code>SYN-ACK</code> handshake: cipher order, extensions, key shares</li> <li>Deterministic profile selection via <code>rustls</code> - non-robust</li> <li>JA3/JA4 string generation and validation</li> </ul> <p>HTTP Layer</p> <ul> <li>Native HTTP/1.1 and HTTP/2 protocol parsing</li> <li>Header ordering, client hints, Accept negotiation</li> </ul> <p>JavaScript Layer</p> <ul> <li>CSP nonce generation synchronized with injection</li> <li>Canvas/WebGL/Audio fingerprint spoofing</li> <li>Iframe boundary propagation</li> <li>Behavioral noise coordination between Rust and JS</li> </ul> <p>Async-Native Rust Architecture</p> <ul> <li>Tokio-based concurrency (no thread pools, no blocking IO)</li> <li>Zero-copy buffers with <code>BytesMut</code></li> <li>Per-flow state isolation (no global locks in hot path)</li> <li>Structured telemetry with <code>tracing</code> (JSON export ready)</li> </ul>"},{"location":"resources/static/#architecture","title":"Architecture","text":"Repository Map <pre><code>static_proxy/\n\u251c\u2500\u2500 Cargo.toml                      # Dependencies: tokio, rustls, h2, hyper, serde\n\u2502\n\u251c\u2500\u2500 assets/js/                      # Embedded fingerprint spoofing scripts\n\u2502   \u251c\u2500\u2500 0bootstrap.js                  # Execution control, eval/Function wrapping\n\u2502   \u251c\u2500\u2500 1globals_shim.js               # Navigator/screen property interception\n\u2502   \u251c\u2500\u2500 2fingerprint_spoof_v2.js       # Canvas, WebGL, audio, font spoofing\n\u2502   \u251c\u2500\u2500 behavioral_noise.js            # Coordinated timing/interaction patterns\n\u2502   \u2514\u2500\u2500 config_layer.js                # Profile injection into JS context\n\u2502\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 static.example.toml         # Listener, TLS, pipeline, telemetry config\n\u2502\n\u251c\u2500\u2500 profiles/                       # JSON profiles (Chrome/Firefox/Edge)\n\u2502   \u251c\u2500\u2500 chrome_latest.json             # Schema v2: headers, TLS, behavior\n\u2502   \u251c\u2500\u2500 firefox_latest.json\n\u2502   \u2514\u2500\u2500 safari_latest.json\n\u2502\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.rs                     # CLI entrypoint (clap args, tracing init)\n\u2502   \u251c\u2500\u2500 app.rs                      # Wires subsystems, spawns listener\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 proxy/                      # Core proxy logic\n\u2502   \u2502   \u251c\u2500\u2500 server.rs                  # TCP listener, protocol detection\n\u2502   \u2502   \u251c\u2500\u2500 connection.rs              # CONNECT handling, TLS termination, HTTP dispatch\n\u2502   \u2502   \u251c\u2500\u2500 flow.rs                    # Request/response/metadata container\n\u2502   \u2502   \u251c\u2500\u2500 pipeline.rs                # Stage orchestration trait\n\u2502   \u2502   \u251c\u2500\u2500 client.rs                  # Upstream dialer (TCP+TLS with profile plans)\n\u2502   \u2502   \u2514\u2500\u2500 stages/                    # HeaderProfile, CSP, JS, AltSvc, Behavioral\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 tls/                        # TLS subsystem\n\u2502   \u2502   \u251c\u2500\u2500 cert.rs                    # CA generation, leaf cert cache (DashMap)\n\u2502   \u2502   \u251c\u2500\u2500 profiles.rs                # TLS planner (JA3/JA4, cipher/group selection)\n\u2502   \u2502   \u251c\u2500\u2500 fingerprint.rs             # JA3 string computation for telemetry\n\u2502   \u2502   \u2514\u2500\u2500 handshake.rs               # rustls ServerConfig/ClientConfig builders\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 config/                     # Configuration system\n\u2502   \u2502   \u251c\u2500\u2500 settings.rs                # StaticConfig struct, TOML deserialization\n\u2502   \u2502   \u2514\u2500\u2500 profiles.rs                # Profile loader with hot reload (notify crate)\n\u2502   \u2502\n\u2502   \u251c\u2500\u2500 behavior/                   # Behavioral noise engine\n\u2502   \u251c\u2500\u2500 assets.rs                   # Embedded JS files, SHA-256 precomputation\n\u2502   \u251c\u2500\u2500 telemetry.rs                # Structured logging (JSON mode, tracing spans)\n\u2502   \u2514\u2500\u2500 utils/                      # Error types, logging helpers\n\u2502\n\u2514\u2500\u2500 tests/\n    \u251c\u2500\u2500 unit/tls_tests.rs              # JA3 serialization, cipher filtering\n    \u2514\u2500\u2500 integration/proxy_tests.rs     # End-to-end flow validation\n</code></pre>"},{"location":"resources/static/#configuration","title":"Configuration","text":"<p>STATIC reads configuration from <code>config/static.toml</code> (or via <code>--config</code> flag). The config file is broken into logical sections that control different subsystems.</p>"},{"location":"resources/static/#listener","title":"Listener","text":"<p>Controls where STATIC binds and listens for incoming connections.</p> <pre><code>[listener]\naddr = \"127.0.0.1\"\nport = 4040\n\n[http3]\nenabled = false\nbind_address = \"127.0.0.1\"\nbind_port = 8081\n</code></pre> HTTP/3 Status <p>HTTP/3 configuration exists but is not yet implemented. STATIC currently handles HTTP/1.1 and HTTP/2 only. When enabled, this will spawn a QUIC listener using <code>quinn</code>.</p>"},{"location":"resources/static/#tls","title":"TLS","text":"<p>Defines paths for CA management and certificate caching.</p> <pre><code>[tls]\nca_cert_path = \"certs/static-ca.crt\"\nca_key_path = \"certs/static-ca.key\"\ncache_dir = \"certs/cache\"\n</code></pre> <p>What happens here:</p> <ul> <li>On first run, STATIC generates a CA certificate and private key</li> <li>Private <code>.key</code> file is stored securely, implementation varies per OS</li> <li>Leaf certificates (for individual domains) are cached in <code>cache_dir</code></li> <li>Cached certs have a 24-hour TTL and are validated on lookup</li> </ul>"},{"location":"resources/static/#pipeline","title":"Pipeline","text":"<p>Controls profile loading, injection behavior, and protocol handling.</p> <pre><code>[pipeline]\nprofiles_path = \"../profiles\"\ndefault_profile = \"firefox-windows\"\njs_debug = false\nalt_svc_strategy = \"normalize\"\n</code></pre> Field Options Purpose <code>profiles_path</code> Path to JSON profiles Where STATIC looks for profile definitions <code>default_profile</code> Profile name Fallback if no profile is selected or profile load fails <code>js_debug</code> <code>true</code>/<code>false</code> Enables verbose JS console output in injected scripts <code>alt_svc_strategy</code> <code>normalize</code>, <code>strip</code>, <code>passthrough</code> How to handle Alt-Svc headers (HTTP/3 downgrade behavior)"},{"location":"resources/static/#telemetry","title":"Telemetry","text":"<p>Configures logging output format and destination.</p> <pre><code>[telemetry]\nmode = \"stdout\"\n</code></pre> Mode Output <code>stdout</code> Pretty-printed logs to console <code>json</code> Structured JSON logs (Loki/ELK ready) <p>Use <code>RUST_LOG</code> environment variable to control verbosity:</p> <pre><code># Human-readable logs\ncargo run\n\n# JSON structured logs\ncargo run -- --json-logs\n\n# Debug everything\nRUST_LOG=static_proxy=debug cargo run\n\n# Trace TLS subsystem only\nRUST_LOG=static_proxy::tls=trace cargo run\n</code></pre>"},{"location":"resources/static/#data-plane","title":"Data Plane","text":"<p>The data plane handles live traffic: protocol detection, TLS termination, request/response mutation, and upstream forwarding.</p>"},{"location":"resources/static/#protocol-detection","title":"Protocol Detection","text":"<p>STATIC peeks at incoming TCP connections to determine what it's dealing with:</p> First Bytes Protocol Handler <code>CONNECT</code> HTTP CONNECT tunnel <code>handle_connect_tunnel</code> <code>0x16</code> Direct TLS ClientHello <code>accept_tls_session</code> <code>GET</code>/<code>POST</code>/etc HTTP/1.1 request <code>handle_http1_session</code>"},{"location":"resources/static/#connect-handling","title":"CONNECT Handling","text":"<ol> <li>Parse <code>CONNECT host:port HTTP/1.1</code> from raw TCP stream</li> <li>Validate hostname (no IP literals, no malformed targets)</li> <li>Respond with <code>200 Connection Established\\r\\n\\r\\n</code></li> <li>Record target in <code>FlowMetadata.connect_target</code> for upstream resolution</li> </ol>"},{"location":"resources/static/#tls-termination","title":"TLS Termination","text":"<ul> <li>Uses <code>tokio_rustls::TlsAcceptor</code> with on-demand certificate generation</li> <li>Extracts SNI from <code>ServerConnection::server_name()</code> (rustls 0.23 API)</li> <li>Falls back to <code>connect_target</code> when SNI is missing (rare, but happens)</li> <li>Generates leaf certificate signed by STATIC CA, caches in <code>DashMap&lt;String, CachedCert&gt;</code></li> </ul>"},{"location":"resources/static/#flow-model","title":"Flow Model","text":"<p>A <code>Flow</code> represents a complete HTTP exchange.</p> <p>Structure:</p> <pre><code>pub struct Flow {\n    id: Uuid,                         // UUID v7 for deterministic ordering\n    request: RequestParts,            // Headers, method, URI, body buffer\n    response: Option&lt;ResponseParts&gt;,  // Populated after upstream response\n    metadata: FlowMetadata,           // Profile, TLS, telemetry state\n    behavioral_noise: BehavioralNoiseMetadata,\n    fingerprint_config: Value,        // Profile JSON for JS injection\n    timers: Timers,                   // Start, stage durations\n    tls_plan: Option&lt;TlsClientPlan&gt;,  // Upstream TLS handshake instructions\n}\n</code></pre> <p>FlowMetadata bridges network stack, pipeline, and telemetry:</p> <ul> <li>TLS SNI and CONNECT target</li> <li>Profile names (header + TLS + behavioral)</li> <li>CSP nonces and script SHA-256 hashes</li> <li>JA3/JA4 strings (computed from TLS plan)</li> <li>Upstream protocol (HTTP/1.1 vs HTTP/2)</li> <li>Stage mutation logs (breadcrumb trail for telemetry)</li> </ul> <p>Performance</p> <p>Buffers use <code>BytesMut</code> for zero-copy mutations during pipeline stages. Headers are reordered in-place without allocating new structures.</p>"},{"location":"resources/static/#pipeline_1","title":"Pipeline","text":"<p>Execution order is deterministic:</p> <pre><code>1. HeaderProfileStage\n   \u2514\u2500 User-Agent, sec-ch-ua, Accept-Language\n   \u2514\u2500 Order: remove \u2192 replace \u2192 replaceArbitrary\n            \u2192 replaceDynamic \u2192 set \u2192 append\n\n2. AltSvcStage\n   \u2514\u2500 Downgrade/strip HTTP/3 advertisements\n   \u2514\u2500 Normalize port lists\n\n3. CspStage\n   \u2514\u2500 Inject CSP nonces\n   \u2514\u2500 Rewrite headers to allow injected JS\n\n4. JsInjectionStage\n   \u2514\u2500 Embed bootstrap + shim + config + spoof\n   \u2514\u2500 Record SHA-256 hashes\n\n5. BehavioralNoiseStage\n   \u2514\u2500 Tag flow with noise plan\n   \u2514\u2500 Coordinate with JS timing patterns\n</code></pre> <p>Each stage implements async hooks:</p> <ul> <li><code>process_request</code> \u2014 Mutates outgoing request before upstream</li> <li><code>process_response_headers</code> \u2014 Mutates headers before body processing</li> <li><code>process_response_body</code> \u2014 Mutates HTML/JS content</li> <li><code>on_complete</code> \u2014 Cleanup, telemetry emission</li> </ul>"},{"location":"resources/static/#headerprofilestage","title":"HeaderProfileStage","text":"<p>Applies header transformations from the profile's <code>headers</code> block.</p> <p>Operations (in order):</p> <ol> <li>remove \u2014 Delete headers by name (case-insensitive)</li> <li>replace \u2014 Overwrite existing headers</li> <li>replaceArbitrary \u2014 Replace with randomized values from a list</li> <li>replaceDynamic \u2014 Template-based replacement (e.g., timestamp injection)</li> <li>set \u2014 Add if missing, overwrite if present</li> <li>append \u2014 Add to existing value or create new header</li> </ol> <p>Why ordering matters:</p> <p>Header order is part of the fingerprint. Real browsers send headers in a specific sequence. STATIC preserves that order from the profile.</p>"},{"location":"resources/static/#altsvcstage","title":"AltSvcStage","text":"<p>HTTP/3 is a fingerprint leak. If your browser advertises <code>h3</code> support but your TLS fingerprint doesn't match a browser that supports HTTP/3, you're identifiable.</p> <p>Strategies:</p> <ul> <li>normalize \u2014 Rewrite <code>Alt-Svc</code> to only advertise HTTP/2</li> <li>strip \u2014 Remove <code>Alt-Svc</code> headers entirely</li> <li>passthrough \u2014 Leave them alone (not recommended)</li> </ul>"},{"location":"resources/static/#cspstage","title":"CspStage","text":"<p>Content Security Policy headers restrict which scripts can execute. STATIC injects JavaScript, so it needs to rewrite CSP headers to whitelist itself.</p> <p>How it works:</p> <ol> <li>Generate a per-flow <code>nonce</code> (cryptographically random, base64-encoded)</li> <li>Compute SHA-256 hashes of injected scripts (precomputed at compile time)</li> <li>Parse existing CSP headers from the response</li> <li>Add <code>'nonce-&lt;value&gt;'</code> and <code>'sha256-&lt;hash&gt;'</code> to <code>script-src</code> directive</li> <li>Preserve <code>'strict-dynamic'</code> if already present (common in modern CSP policies)</li> </ol> <p>CSP determinism:</p> <p>Script load order matters. STATIC always injects in the same order (0bootstrap \u2192 1globals_shim \u2192 config_layer \u2192 2fingerprint_spoof_v2 \u2192 behavioral_noise) to ensure CSP hashes remain valid.</p>"},{"location":"resources/static/#jsinjectionstage","title":"JsInjectionStage","text":"<p>Embeds the fingerprint spoofing stack into HTML responses.</p> <p>Injection point:</p> <ul> <li>Near <code>&lt;/head&gt;</code> (preferred)</li> <li>Near <code>&lt;/body&gt;</code> (fallback)</li> <li>Synthesize <code>&lt;head&gt;</code> if missing (rare, but handles malformed HTML)</li> </ul> <p>Injected scripts:</p> <pre><code>&lt;script nonce=\"generated-nonce\"&gt;\n// 0bootstrap.js \u2014 Execution control, prevents double-injection\n&lt;/script&gt;\n&lt;script nonce=\"generated-nonce\"&gt;\n// 1globals_shim.js \u2014 Intercepts navigator/screen/window properties\n&lt;/script&gt;\n&lt;script nonce=\"generated-nonce\"&gt;\n// config_layer.js + profile JSON \u2014 Writes __STATIC_CONFIG__\n&lt;/script&gt;\n&lt;script nonce=\"generated-nonce\"&gt;\n// 2fingerprint_spoof_v2.js \u2014 Canvas/WebGL/Audio/Font spoofing\n&lt;/script&gt;\n&lt;script nonce=\"generated-nonce\"&gt;\n// behavioral_noise.js \u2014 Timing patterns, coordinated with Rust\n&lt;/script&gt;\n</code></pre> <p>Decompression:</p> <p>Responses may be gzip/deflate/brotli-encoded. STATIC decompresses, injects, and re-compresses (or strips <code>Content-Encoding</code> and updates <code>Content-Length</code>).</p>"},{"location":"resources/static/#behavioralnoisestage","title":"BehavioralNoiseStage","text":"<p>Experimental feature, not fully implemented!</p> <p>Tags flows with timing patterns and interaction metadata. The JavaScript layer reads these patterns and coordinates behavior (e.g., randomized delays, simulated mouse movements).</p> <p>Rust side:</p> <ul> <li>Parses behavioral strategies from profile JSON</li> <li>Writes metadata to <code>Flow.behavioral_noise</code></li> <li>Marks flow as <code>behavioral_noise.enabled</code></li> </ul> <p>JavaScript side:</p> <ul> <li>Reads <code>__STATIC_CONFIG__.behavioral_noise</code></li> <li>Annotates outgoing requests with timing metadata</li> <li>Modifies DOM interactions to avoid deterministic patterns</li> </ul>"},{"location":"resources/static/#http11-engine","title":"HTTP/1.1 Engine","text":"<p>Flow (<code>connection.rs::handle_http1_session</code>):</p> <pre><code>parse_http_request (chunked decoder normalizes to contiguous buffer)\n         \u2193\nStage pipeline mutates request\n         \u2193\nUpstream connect/dial\n         \u2193\nsend_request_to_upstream()\n         \u2193\nparse_http_response (buffer complete response)\n         \u2193\nStage pipeline mutates response\n         \u2193\nsend_response_to_client()\n</code></pre> <p>Edge cases handled:</p> <ul> <li>Bodyless status codes (1xx/204/205/304) \u2014 Skip Content-Length validation to avoid hangs</li> <li>Chunked encoding \u2014 Normalize to contiguous buffer for pipeline processing</li> <li>Connection: close \u2014 Properly tear down TCP stream after response</li> </ul> <p>Limitation: Streaming Bodies</p> <p>HTTP/1 engine currently buffers entire request/response. Large uploads/downloads may pressure memory. Streaming support is planned.</p>"},{"location":"resources/static/#http2-engine","title":"HTTP/2 Engine","text":"<p>Flow (<code>connection.rs::handle_http2_session</code>):</p> <ul> <li>Leverages <code>h2::server</code> for client-side HTTP/2 framing (ALPN <code>h2</code>)</li> <li>Each incoming stream spawns <code>process_http2_stream()</code> for per-request state isolation</li> </ul> <p>Upstream branching:</p> <ul> <li><code>forward_h2_over_h2()</code> \u2014 When origin negotiates HTTP/2 (ALPN <code>h2</code>)</li> <li><code>forward_h2_via_http1()</code> \u2014 Fallback when upstream ALPN lacks <code>h2</code></li> </ul> <p>Response handling:</p> <ul> <li>Buffers complete headers/body before running response stages</li> <li><code>sanitize_response_headers_for_h2()</code> removes hop-by-hop headers (<code>Connection</code>, <code>Transfer-Encoding</code>, etc.)</li> <li>Enforces <code>Content-Length</code>, normalizes lowercase header names (HTTP/2 spec requirement)</li> </ul> <p>Flow control:</p> <ul> <li><code>RecvStream::flow_control().release_capacity()</code> per chunk</li> <li>Prevents zero-window deadlocks</li> <li>10-second timeout guard prevents hung upstream from blocking client</li> </ul> <p>Pseudo-header validation:</p> <p>HTTP/2 requires pseudo-headers (<code>:method</code>, <code>:scheme</code>, <code>:authority</code>, <code>:path</code>) at the start of the header block. STATIC enforces this on both request and response sides.</p>"},{"location":"resources/static/#http3-roadmap","title":"HTTP/3 Roadmap","text":"<p><code>Http3Config</code> already exists in <code>StaticConfig</code>. Implementation pending:</p> <ul> <li><code>proxy::quic</code> module built on <code>quinn</code></li> <li>CONNECT-UDP handler (RFC 9298)</li> <li>ALPS serialization within TLS planner</li> <li>Telemetry labels for H3 flows</li> </ul>"},{"location":"resources/static/#limitations","title":"Limitations","text":"<p>STATIC is powerful but has known limitations. These are being actively worked on.</p>"},{"location":"resources/static/#tls-coverage","title":"TLS Coverage","text":"<p>Missing from rustls/aws-lc:</p> <ul> <li>RSA key exchange \u2014 Only ECDHE is supported</li> <li>GREASE ciphers/extensions \u2014 Rustls doesn't support GREASE values</li> <li>Post-quantum hybrid key shares \u2014 PQ crypto support is experimental</li> </ul> <p>Warning</p> <p>JA3 limited to ECDHE suites until BoringSSL integration is complete. Some browser profiles (older Safari, Edge) cannot be fully emulated.</p>"},{"location":"resources/static/#http3","title":"HTTP/3","text":"<p>Status: Config + roadmap exist, but no QUIC listener yet.</p> <p>Current behavior: TLS planner clamps ALPN to <code>['h2','http/1.1']</code>.</p> <p>Planned:</p> <ul> <li><code>proxy::quic</code> module built on <code>quinn</code></li> <li>CONNECT-UDP handler (RFC 9298)</li> <li>ALPS serialization for TLS 1.3</li> </ul>"},{"location":"resources/static/#streaming-bodies","title":"Streaming Bodies","text":"<p>HTTP/1 engine buffers entire request/response in memory.</p> <p>Impact: Large uploads/downloads (&gt;100MB) may pressure memory and cause high latency.</p> <p>Planned: </p> <ul> <li>Streaming pipeline with chunked rewriter and stage API adjustments (stages would operate on body chunks instead of complete buffers).</li> </ul>"},{"location":"resources/static/#connection-pooling","title":"Connection Pooling","text":"<p>Current behavior:</p> <ul> <li>Upstream dials fresh TCP/TLS per request</li> <li>No keepalive/persistent connections</li> <li>No configurable timeouts</li> </ul> <p>Impact: Higher latency, more TLS handshakes, easier to fingerprint by timing patterns.</p> <p>Planned:</p> <ul> <li>Connection pool with keepalive (idle timeout, max connections per host)</li> <li>Configurable dial/read/write timeouts</li> <li>Happy Eyeballs DNS resolution (parallel IPv4/IPv6)</li> </ul>"},{"location":"resources/static/#dns-caching","title":"DNS Caching","text":"<p>Minimal caching implemented. Relies on OS resolver (<code>tokio::net::lookup_host</code>).</p> <p>Planned: </p> <ul> <li>Happy Eyeballs with internal DNS cache (reduce resolution latency, improve consistency).</li> </ul>"}]}